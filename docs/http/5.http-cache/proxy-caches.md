---
title: 缓存代理
---

import Img from '../../../src/components/Img';

## 代理服务

**代理服务本身不生产内容，而是处于中间位置转发上下游的请求和响应**，具有双重身份：面向下游的用户时，表现为服务器，代表源服务器响应客户端的请求；而面向上游的源服务器时，又表现为客户端，代表客户端发送请求。如下图所示：

<Img w="600" legend="代理服务器示意图" src="https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200106221833.png" />

常见的代理服务有“正向代理”和“反向代理”，关于这部分的内容可以看[正向代理和反向代理](/blog/2019/11/04/Reverse-Proxy)这篇博客。

## 代理服务器缓存

上一节主要讲述了服务器通过响应报文`Cache-Control`字段控制客户端缓存，它能够减少响应时间、节约带宽，提升客户端的用户体验。但 HTTP 传输链路上，不只是客户端有缓存，**代理服务器上也是可以缓存数据的**。代理服务器缓存可以让请求不必走完整个后续处理流程，“就近”获得响应结果。 <Img w="600" src="https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200107130032.png" />

代理服务收到源服务器发来的响应数据后需要做两件事：

1. 把报文转发给客户端。
2. 把报文存入自己的`Cache`里。

当客户端有相同的请求时，代理服务器就可以直接发送 304 或者缓存数据，不必再从源服务器那里获取。这样就降低了客户端的等待时间，同时节约了源服务器的网络带宽。

## 缓存控制

在 HTTP 的缓存体系中，代理服务器的身份十分特殊，它“既是客户端，又是服务器”。但代理服务器也“即不是客户端又不是服务器”，因为它只是一个数据的“中转站”，并不是真正的数据消费者和生产者，所以还需要有一些新的“Cache-Control”属性来对它做特别的约束。

<Img w="600" legend="图：Cache-Control常用字段" src="https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200106233006.png" />

如上图，前四个字段在上节服务器控制客户端缓存中已经介绍过，这四个字段也同样适合代理服务器。除此之外，源服务器为了控制缓存服务器缓存的资源，还可以在响应报文的`Cache-Control`字段中添加`private`、`public`等字段来进一步的控制代理服务器缓存。

当客户端首次发送请求报文的时候会去源服务器请求资源，如果整条链路中有代理服务器，代理服务器会缓存源服务器响应的资源。

<Img w="600" legend="图：源服务器控制代理服务器缓存" src="https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/20200107123338.png" />

如上图所示：

- 源服务器通过`no-store`参数来控制响应的资源是否可以被缓存。
- 通过`no-cache`参数控制客户端或者代理服务器缓存使用时必须向源服务器进行验证。
- 通过`must-revalidate`控制客户端缓存不过期就可以继续使用，但过期了就必须去源服务器验证。
- 与`must-revalidate`功能相似，只不过`proxy-revalidate`用来控制代理服务器资源。
- 通过`private`控制资源只能被客户端缓存，而不能被代理服务器缓存。
- 通过`public`参数控制资源即可以被客户端缓存，也可以被代理服务器缓存。
- `s-maxage`与`max-age`功能类似，`max-age`是控制客户端缓存的相对过期时间，而`s-maxage`是针对代理服务器缓存资源的相对过期时间。
- 通过`no-transform`字段可以告知代理服务器缓存资源的时候，不可以更改媒体类型。

上述所讲都是通过`Cache-Control`设置的**强缓存**，当然也可以设置`Last-Modified`和`Etag`来控制代理服务器的**协商缓存**。因为代理服务器的协商缓存控制策略和客户端（浏览器）的控制策略相同，所以此处不再赘述。
