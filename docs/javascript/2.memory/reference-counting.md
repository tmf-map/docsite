---
title: 引用计数
---

引用计数（Reference Count）方式是 GC 算法中最简单也最容易实现的一种，它和标记清除方式差不多是在同一时间发明出来的，第一个 js 版本大概是 90 年代初的事情。

引用计数的基本原理是，在每个对象中保存该对象的引用计数，当引用发生增减时对计数进行更新。引用计数的增减，一般发生在变量赋值、对象内容更新、函数结束（局部变量不再被引用）等时间点。当一个对象的引用计数变为 0 时，则说明它将来不会再被引用，因此可以释放相应的内存空间。

引用计数的优势在于效率是最高的，因此移动端 native 还在用。但缺点是**循环引用会有可能内存泄漏**，还不能做并行 GC。

在低版本 IE 中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。虽然 JavaScript 对象通过标记清除的方式进行垃圾回收，但 BOM 与 DOM 对象却是通过引用计数回收垃圾的，也就是说 IE 中只要涉及 BOM 及 DOM 就会出现循环引用问题。

引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加 1，如果该变量的值变成了另外一个，则这个值得引用次数减 1，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间。

语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是 0，就表示这个值不再用到了，因此可以将这块内存释放。

<Img src='https://cosmos-x.oss-cn-hangzhou.aliyuncs.com/jEdPCn.jpg' width="400"/>

上图中，左下角的两个值，没有任何引用，所以可以释放。

如果一个值不再需要了，引用数却不为 0，垃圾回收机制无法释放这块内存，从而导致内存泄漏。

```js
const arr = [1, 2, 3, 4];
console.log('hello world');
```

上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量 arr 是仅有的对这个值的引用，因此引用次数为 1。尽管后面的代码没有用到 arr，它还是会持续占用内存。

如果增加一行代码，解除 arr 对[1, 2, 3, 4]引用，这块内存就可以被垃圾回收机制释放了。

```js
let arr = [1, 2, 3, 4];
console.log('hello world');
arr = null;
```

上面代码中，arr 重置为 null，就解除了对[1, 2, 3, 4]的引用，引用次数变成了 0，内存就可以释放出来了。

因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就**必须手动解除引用**。比如闭包如果没有及时解除引用也会产生内存泄漏问题。
